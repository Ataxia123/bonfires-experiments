<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bonfire Pulse — EthBoulder 2026</title>
<style>
/* ─────────────────────────────────────────────
   RESET & BASE
   ───────────────────────────────────────────── */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg-deep:    #0d0a07;
  --bg-surface: #1a1410;
  --bg-card:    #231c14;
  --bg-card-hi: #2e2418;
  --amber-dim:  #7a5c2e;
  --amber:      #d4952b;
  --amber-hot:  #f5a623;
  --amber-glow: #ffbd45;
  --orange:     #e8742a;
  --ember:      #c94a1a;
  --cream:      #f0e6d3;
  --cream-dim:  #b8a88e;
  --cream-faint:#8a7d6a;
  --radius:     12px;
  --radius-sm:  8px;
  --shadow-glow: 0 0 30px rgba(212, 149, 43, 0.08);
  --shadow-card: 0 2px 12px rgba(0,0,0,0.4);
  --transition:  0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

html { font-size: 15px; }
body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
  background: var(--bg-deep);
  color: var(--cream);
  min-height: 100vh;
  overflow-x: hidden;
  line-height: 1.5;
}

/* Ambient animated background */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background:
    radial-gradient(ellipse 80% 60% at 20% 10%, rgba(212,149,43,0.06) 0%, transparent 60%),
    radial-gradient(ellipse 60% 80% at 80% 90%, rgba(232,116,42,0.04) 0%, transparent 50%),
    radial-gradient(ellipse 50% 50% at 50% 50%, rgba(201,74,26,0.03) 0%, transparent 70%);
  pointer-events: none;
  z-index: 0;
  animation: ambientShift 20s ease-in-out infinite alternate;
}

@keyframes ambientShift {
  0%   { opacity: 0.7; transform: scale(1); }
  50%  { opacity: 1;   transform: scale(1.05); }
  100% { opacity: 0.8; transform: scale(0.98); }
}

/* ─────────────────────────────────────────────
   LAYOUT
   ───────────────────────────────────────────── */
.dashboard {
  position: relative;
  z-index: 1;
  max-width: 1440px;
  margin: 0 auto;
  padding: 20px 24px 40px;
  display: grid;
  gap: 20px;
  grid-template-columns: 1fr;
  grid-template-rows: auto auto auto auto;
}

/* ─────────────────────────────────────────────
   HEADER
   ───────────────────────────────────────────── */
.header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 12px;
  padding: 16px 0 8px;
}

.header-left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.header h1 {
  font-size: 1.8rem;
  font-weight: 800;
  letter-spacing: -0.02em;
  background: linear-gradient(135deg, var(--amber-glow), var(--orange));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.pulse-dot {
  width: 12px; height: 12px;
  border-radius: 50%;
  background: var(--amber-hot);
  box-shadow: 0 0 8px var(--amber-hot), 0 0 20px rgba(245,166,35,0.4);
  animation: pulseDot 2s ease-in-out infinite;
  flex-shrink: 0;
}

@keyframes pulseDot {
  0%, 100% { transform: scale(1);   opacity: 1; }
  50%      { transform: scale(1.4); opacity: 0.6; }
}

.header-subtitle {
  font-size: 0.85rem;
  color: var(--cream-dim);
  font-weight: 400;
  letter-spacing: 0.04em;
}

.header-right {
  display: flex;
  align-items: center;
  gap: 16px;
  font-size: 0.8rem;
  color: var(--cream-faint);
}

.refresh-timer {
  display: flex;
  align-items: center;
  gap: 6px;
  background: var(--bg-card);
  padding: 6px 14px;
  border-radius: 20px;
  border: 1px solid rgba(212,149,43,0.15);
}

.refresh-timer .ring {
  width: 18px; height: 18px;
  border-radius: 50%;
  border: 2px solid var(--amber-dim);
  position: relative;
}

.refresh-timer .ring::after {
  content: '';
  position: absolute;
  inset: 2px;
  border-radius: 50%;
  border: 2px solid transparent;
  border-top-color: var(--amber-hot);
  animation: timerSpin 60s linear infinite;
}

@keyframes timerSpin {
  to { transform: rotate(360deg); }
}

.status-badge {
  padding: 5px 12px;
  border-radius: 20px;
  font-size: 0.75rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
}

.status-badge.loading {
  background: rgba(212,149,43,0.15);
  color: var(--amber-hot);
  border: 1px solid rgba(212,149,43,0.3);
  animation: statusPulse 1.5s ease-in-out infinite;
}

.status-badge.live {
  background: rgba(76,175,80,0.15);
  color: #81c784;
  border: 1px solid rgba(76,175,80,0.3);
}

.status-badge.error {
  background: rgba(201,74,26,0.15);
  color: #e57373;
  border: 1px solid rgba(201,74,26,0.3);
}

@keyframes statusPulse {
  0%, 100% { opacity: 1; }
  50%      { opacity: 0.5; }
}

/* ─────────────────────────────────────────────
   STAT CARDS
   ───────────────────────────────────────────── */
.stats-row {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 16px;
}

.stat-card {
  background: var(--bg-card);
  border: 1px solid rgba(212,149,43,0.1);
  border-radius: var(--radius);
  padding: 24px;
  text-align: center;
  position: relative;
  overflow: hidden;
  transition: var(--transition);
  box-shadow: var(--shadow-card);
}

.stat-card::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 3px;
  background: linear-gradient(90deg, var(--amber), var(--orange));
  opacity: 0.6;
}

.stat-card:hover {
  border-color: rgba(212,149,43,0.25);
  transform: translateY(-2px);
  box-shadow: var(--shadow-glow), var(--shadow-card);
}

.stat-card .stat-value {
  font-size: 2.8rem;
  font-weight: 800;
  background: linear-gradient(135deg, var(--amber-glow), var(--orange));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  line-height: 1.1;
  margin-bottom: 4px;
  transition: var(--transition);
}

.stat-card .stat-label {
  font-size: 0.8rem;
  color: var(--cream-dim);
  text-transform: uppercase;
  letter-spacing: 0.1em;
  font-weight: 500;
}

.stat-card .stat-icon {
  font-size: 1.4rem;
  margin-bottom: 8px;
  opacity: 0.7;
}

/* ─────────────────────────────────────────────
   MAIN CONTENT GRID
   ───────────────────────────────────────────── */
.content-grid {
  display: grid;
  grid-template-columns: 60fr 40fr;
  gap: 20px;
  min-height: 500px;
}

/* ─── PANEL BASE ─── */
.panel {
  background: var(--bg-card);
  border: 1px solid rgba(212,149,43,0.08);
  border-radius: var(--radius);
  box-shadow: var(--shadow-card);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px 12px;
  border-bottom: 1px solid rgba(212,149,43,0.08);
}

.panel-title {
  font-size: 0.95rem;
  font-weight: 700;
  color: var(--amber-glow);
  letter-spacing: 0.02em;
}

.panel-count {
  font-size: 0.7rem;
  background: rgba(212,149,43,0.12);
  color: var(--amber);
  padding: 3px 10px;
  border-radius: 12px;
  font-weight: 600;
}

.panel-body {
  flex: 1;
  overflow-y: auto;
  padding: 12px 16px;
}

/* scrollbar */
.panel-body::-webkit-scrollbar { width: 5px; }
.panel-body::-webkit-scrollbar-track { background: transparent; }
.panel-body::-webkit-scrollbar-thumb {
  background: var(--amber-dim);
  border-radius: 4px;
}

/* ─── EPISODES TIMELINE ─── */
.episode-card {
  background: var(--bg-surface);
  border: 1px solid rgba(212,149,43,0.06);
  border-radius: var(--radius-sm);
  padding: 14px 16px;
  margin-bottom: 10px;
  transition: var(--transition);
  cursor: default;
  position: relative;
}

.episode-card::before {
  content: '';
  position: absolute;
  left: 0; top: 0; bottom: 0;
  width: 3px;
  background: linear-gradient(180deg, var(--amber-hot), var(--orange));
  border-radius: 3px 0 0 3px;
  opacity: 0;
  transition: var(--transition);
}

.episode-card:hover {
  border-color: rgba(212,149,43,0.2);
  background: var(--bg-card-hi);
  box-shadow: 0 0 20px rgba(212,149,43,0.06);
  transform: translateX(3px);
}

.episode-card:hover::before { opacity: 1; }

.episode-name {
  font-weight: 700;
  font-size: 0.9rem;
  color: var(--cream);
  margin-bottom: 6px;
  line-height: 1.3;
}

.episode-content {
  font-size: 0.8rem;
  color: var(--cream-dim);
  line-height: 1.55;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.episode-source {
  font-size: 0.7rem;
  color: var(--cream-faint);
  margin-top: 8px;
  font-style: italic;
}

/* ─── RIGHT COLUMN ─── */
.right-column {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* ─── ENTITIES LIST ─── */
.entity-cloud {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  padding: 4px;
  align-content: flex-start;
}

.entity-tag {
  display: inline-flex;
  align-items: center;
  padding: 5px 14px;
  border-radius: 20px;
  font-weight: 600;
  white-space: nowrap;
  transition: var(--transition);
  cursor: default;
  border: 1px solid;
}

.entity-tag:hover {
  transform: scale(1.08);
  box-shadow: 0 0 16px rgba(212,149,43,0.2);
}

.entity-tag.size-xl {
  font-size: 1rem; padding: 7px 18px;
  background: rgba(245,166,35,0.18); color: var(--amber-glow);
  border-color: rgba(245,166,35,0.35);
}
.entity-tag.size-lg {
  font-size: 0.88rem; padding: 6px 15px;
  background: rgba(212,149,43,0.14); color: var(--amber-hot);
  border-color: rgba(212,149,43,0.28);
}
.entity-tag.size-md {
  font-size: 0.78rem;
  background: rgba(232,116,42,0.1); color: var(--orange);
  border-color: rgba(232,116,42,0.22);
}
.entity-tag.size-sm {
  font-size: 0.72rem; padding: 4px 11px;
  background: rgba(122,92,46,0.12); color: var(--cream-dim);
  border-color: rgba(122,92,46,0.2);
}

/* ─── FORCE GRAPH ─── */
.graph-container {
  flex: 1;
  min-height: 280px;
  position: relative;
}

.graph-container canvas {
  width: 100%;
  height: 100%;
  display: block;
  border-radius: 0 0 var(--radius) var(--radius);
}

/* ─────────────────────────────────────────────
   PULSE TOPICS (BOTTOM)
   ───────────────────────────────────────────── */
.pulse-topics {
  background: var(--bg-card);
  border: 1px solid rgba(212,149,43,0.08);
  border-radius: var(--radius);
  box-shadow: var(--shadow-card);
  overflow: hidden;
}

.pulse-topics .panel-header {
  border-bottom: 1px solid rgba(212,149,43,0.08);
}

.topics-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 1px;
  background: rgba(212,149,43,0.06);
}

.topic-column {
  background: var(--bg-card);
  padding: 16px;
  min-height: 200px;
}

.topic-heading {
  font-size: 0.78rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  margin-bottom: 14px;
  padding-bottom: 8px;
  border-bottom: 2px solid;
  display: flex;
  align-items: center;
  gap: 8px;
}

.topic-heading .topic-icon { font-size: 1rem; }

.topic-heading.people   { color: #f5a623; border-color: #f5a623; }
.topic-heading.projects { color: #e8742a; border-color: #e8742a; }
.topic-heading.ideas    { color: #c94a1a; border-color: #c94a1a; }
.topic-heading.places   { color: #d4952b; border-color: #d4952b; }
.topic-heading.emerging { color: #ffbd45; border-color: #ffbd45; }

.topic-item {
  font-size: 0.78rem;
  color: var(--cream-dim);
  padding: 7px 0;
  border-bottom: 1px solid rgba(255,255,255,0.03);
  line-height: 1.4;
  transition: var(--transition);
}

.topic-item:hover { color: var(--cream); padding-left: 4px; }

.topic-item .topic-item-name {
  font-weight: 600;
  color: var(--cream);
  display: block;
  margin-bottom: 2px;
}

.topic-item .topic-item-detail {
  font-size: 0.72rem;
  color: var(--cream-faint);
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

/* ─── LOADING / PLACEHOLDER ─── */
.loading-placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  min-height: 120px;
  color: var(--cream-faint);
  font-size: 0.85rem;
  gap: 10px;
}

.loading-spinner {
  width: 18px; height: 18px;
  border: 2px solid var(--amber-dim);
  border-top-color: var(--amber-hot);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin { to { transform: rotate(360deg); } }

/* ─────────────────────────────────────────────
   RESPONSIVE
   ───────────────────────────────────────────── */
@media (max-width: 1100px) {
  .content-grid { grid-template-columns: 1fr; }
  .topics-grid  { grid-template-columns: repeat(3, 1fr); }
}

@media (max-width: 768px) {
  html { font-size: 14px; }
  .dashboard { padding: 12px 14px 30px; }
  .stats-row  { grid-template-columns: 1fr; }
  .topics-grid { grid-template-columns: 1fr 1fr; }
  .header h1 { font-size: 1.4rem; }
  .stat-card .stat-value { font-size: 2rem; }
}

@media (max-width: 480px) {
  .topics-grid { grid-template-columns: 1fr; }
}

/* ─── FADE-IN ANIMATION ─── */
@keyframes fadeUp {
  from { opacity: 0; transform: translateY(12px); }
  to   { opacity: 1; transform: translateY(0); }
}

.fade-in {
  animation: fadeUp 0.5s ease-out both;
}
</style>
</head>
<body>

<div class="dashboard">

  <!-- ═══════ HEADER ═══════ -->
  <header class="header">
    <div class="header-left">
      <span class="pulse-dot"></span>
      <div>
        <h1>Bonfire Pulse</h1>
        <div class="header-subtitle">EthBoulder 2026 &mdash; Collective Intelligence Dashboard</div>
      </div>
    </div>
    <div class="header-right">
      <div class="refresh-timer">
        <div class="ring"></div>
        <span id="countdown">60s</span>
      </div>
      <span class="status-badge loading" id="statusBadge">Loading</span>
    </div>
  </header>

  <!-- ═══════ STATS ROW ═══════ -->
  <div class="stats-row">
    <div class="stat-card">
      <div class="stat-icon">&#x1F4AC;</div>
      <div class="stat-value" id="statEpisodes">--</div>
      <div class="stat-label">Episodes Captured</div>
    </div>
    <div class="stat-card">
      <div class="stat-icon">&#x2B50;</div>
      <div class="stat-value" id="statEntities">--</div>
      <div class="stat-label">Unique Entities</div>
    </div>
    <div class="stat-card">
      <div class="stat-icon">&#x1F517;</div>
      <div class="stat-value" id="statEdges">--</div>
      <div class="stat-label">Connections Mapped</div>
    </div>
  </div>

  <!-- ═══════ MAIN CONTENT ═══════ -->
  <div class="content-grid">

    <!-- LEFT: Episodes Timeline -->
    <div class="panel" id="episodesPanel">
      <div class="panel-header">
        <span class="panel-title">Recent Memories</span>
        <span class="panel-count" id="episodesCount">--</span>
      </div>
      <div class="panel-body" id="episodesList">
        <div class="loading-placeholder"><div class="loading-spinner"></div> Retrieving memories...</div>
      </div>
    </div>

    <!-- RIGHT COLUMN -->
    <div class="right-column">

      <!-- Key Entities -->
      <div class="panel" style="max-height: 320px;">
        <div class="panel-header">
          <span class="panel-title">Key Entities</span>
          <span class="panel-count" id="entitiesCount">--</span>
        </div>
        <div class="panel-body" id="entitiesList">
          <div class="loading-placeholder"><div class="loading-spinner"></div> Mapping entities...</div>
        </div>
      </div>

      <!-- Force Graph -->
      <div class="panel" style="flex: 1;">
        <div class="panel-header">
          <span class="panel-title">Relationship Web</span>
          <span class="panel-count" id="graphCount">--</span>
        </div>
        <div class="graph-container" id="graphContainer">
          <canvas id="forceCanvas"></canvas>
        </div>
      </div>

    </div>
  </div>

  <!-- ═══════ PULSE TOPICS ═══════ -->
  <div class="pulse-topics">
    <div class="panel-header">
      <span class="panel-title">Pulse Topics</span>
      <span class="panel-count" id="topicsStatus">Loading 5 queries...</span>
    </div>
    <div class="topics-grid" id="topicsGrid">

      <div class="topic-column" id="topicPeople">
        <div class="topic-heading people"><span class="topic-icon">&#x1F465;</span> People</div>
        <div class="loading-placeholder" style="min-height:80px"><div class="loading-spinner"></div></div>
      </div>

      <div class="topic-column" id="topicProjects">
        <div class="topic-heading projects"><span class="topic-icon">&#x1F3D7;</span> Projects</div>
        <div class="loading-placeholder" style="min-height:80px"><div class="loading-spinner"></div></div>
      </div>

      <div class="topic-column" id="topicIdeas">
        <div class="topic-heading ideas"><span class="topic-icon">&#x1F4A1;</span> Ideas &amp; Themes</div>
        <div class="loading-placeholder" style="min-height:80px"><div class="loading-spinner"></div></div>
      </div>

      <div class="topic-column" id="topicPlaces">
        <div class="topic-heading places"><span class="topic-icon">&#x1F30D;</span> Places &amp; Spaces</div>
        <div class="loading-placeholder" style="min-height:80px"><div class="loading-spinner"></div></div>
      </div>

      <div class="topic-column" id="topicEmerging">
        <div class="topic-heading emerging"><span class="topic-icon">&#x26A1;</span> Emerging</div>
        <div class="loading-placeholder" style="min-height:80px"><div class="loading-spinner"></div></div>
      </div>

    </div>
  </div>

</div>

<script>
// ═══════════════════════════════════════════════════
// CONFIGURATION
// ═══════════════════════════════════════════════════
const CONFIG = {
  API_BASE:    location.hostname === 'localhost' ? '/api' : 'https://tnt-v2.api.bonfires.ai',
  API_KEY:     '8n5l-sJnrHjywrTnJ3rJCjo1f1uLyTPYy_yLgq_bf-d',
  BONFIRE_ID:  '698b70002849d936f4259848',
  REFRESH_SEC: 60,
  NUM_RESULTS: 20,
};

// ═══════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════
let allEpisodes  = new Map(); // uuid -> episode
let allEntities  = new Map(); // uuid -> { name, edgeCount }
let allEdges     = [];
let countdown    = CONFIG.REFRESH_SEC;
let refreshTimer = null;
let graphSim     = null;

// ═══════════════════════════════════════════════════
// API
// ═══════════════════════════════════════════════════
async function delve(query) {
  const res = await fetch(`${CONFIG.API_BASE}/delve`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${CONFIG.API_KEY}`,
    },
    body: JSON.stringify({
      query,
      bonfire_id: CONFIG.BONFIRE_ID,
      num_results: CONFIG.NUM_RESULTS,
    }),
  });
  if (!res.ok) throw new Error(`API ${res.status}: ${res.statusText}`);
  return res.json();
}

// ═══════════════════════════════════════════════════
// DATA AGGREGATION
// ═══════════════════════════════════════════════════
function mergeResults(data) {
  if (!data || !data.success) return;

  // Episodes
  if (data.episodes) {
    for (const ep of data.episodes) {
      if (!allEpisodes.has(ep.uuid)) {
        allEpisodes.set(ep.uuid, ep);
      }
    }
  }

  // Entities — count edges per entity
  if (data.entities) {
    for (const ent of data.entities) {
      if (!allEntities.has(ent.uuid)) {
        allEntities.set(ent.uuid, { ...ent, edgeCount: 0 });
      }
    }
  }

  // Edges
  if (data.edges) {
    for (const edge of data.edges) {
      const exists = allEdges.some(e =>
        e.source_uuid === edge.source_uuid &&
        e.target_uuid === edge.target_uuid &&
        e.name === edge.name
      );
      if (!exists) {
        allEdges.push(edge);
        // increment edge counts
        const src = allEntities.get(edge.source_uuid);
        if (src) src.edgeCount++;
        const tgt = allEntities.get(edge.target_uuid);
        if (tgt) tgt.edgeCount++;
      }
    }
  }
}

// ═══════════════════════════════════════════════════
// RENDER: Stats
// ═══════════════════════════════════════════════════
function animateNumber(el, target) {
  const current = parseInt(el.textContent) || 0;
  if (current === target) return;
  const diff = target - current;
  const steps = Math.min(Math.abs(diff), 30);
  const stepTime = 600 / steps;
  let i = 0;
  const interval = setInterval(() => {
    i++;
    const progress = i / steps;
    const eased = 1 - Math.pow(1 - progress, 3);
    el.textContent = Math.round(current + diff * eased);
    if (i >= steps) { el.textContent = target; clearInterval(interval); }
  }, stepTime);
}

function renderStats() {
  animateNumber(document.getElementById('statEpisodes'), allEpisodes.size);
  animateNumber(document.getElementById('statEntities'), allEntities.size);
  animateNumber(document.getElementById('statEdges'), allEdges.length);
}

// ═══════════════════════════════════════════════════
// RENDER: Episodes
// ═══════════════════════════════════════════════════
function renderEpisodes() {
  const container = document.getElementById('episodesList');
  const episodes = [...allEpisodes.values()]
    .sort((a, b) => (a.name || '').localeCompare(b.name || ''));

  document.getElementById('episodesCount').textContent = episodes.length;

  if (episodes.length === 0) {
    container.innerHTML = '<div class="loading-placeholder">No episodes found</div>';
    return;
  }

  container.innerHTML = episodes.map((ep, i) => `
    <div class="episode-card fade-in" style="animation-delay: ${i * 40}ms">
      <div class="episode-name">${escHtml(ep.name || 'Unnamed')}</div>
      <div class="episode-content">${escHtml(truncate(ep.content || '', 220))}</div>
      ${ep.source_description ? `<div class="episode-source">${escHtml(ep.source_description)}</div>` : ''}
    </div>
  `).join('');
}

// ═══════════════════════════════════════════════════
// RENDER: Entities
// ═══════════════════════════════════════════════════
function renderEntities() {
  const container = document.getElementById('entitiesList');
  const entities = [...allEntities.values()]
    .sort((a, b) => b.edgeCount - a.edgeCount);

  document.getElementById('entitiesCount').textContent = entities.length;

  if (entities.length === 0) {
    container.innerHTML = '<div class="loading-placeholder">No entities found</div>';
    return;
  }

  const maxEdges = Math.max(1, entities[0].edgeCount);

  container.innerHTML = `<div class="entity-cloud">` +
    entities.map((ent, i) => {
      const ratio = ent.edgeCount / maxEdges;
      let size = 'sm';
      if (ratio > 0.7) size = 'xl';
      else if (ratio > 0.4) size = 'lg';
      else if (ratio > 0.15) size = 'md';

      return `<span class="entity-tag size-${size} fade-in" style="animation-delay: ${i * 25}ms" title="${ent.edgeCount} connections">${escHtml(ent.name)}</span>`;
    }).join('') +
    `</div>`;
}

// ═══════════════════════════════════════════════════
// RENDER: Force Graph
// ═══════════════════════════════════════════════════
function initForceGraph() {
  const canvas = document.getElementById('forceCanvas');
  const container = document.getElementById('graphContainer');
  const ctx = canvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;

  function resize() {
    const rect = container.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  resize();
  window.addEventListener('resize', resize);

  // Build node/edge arrays from entity/edge data
  let nodes = [];
  let links = [];
  let dragNode = null;
  let mouseX = 0, mouseY = 0;
  let hoveredNode = null;

  function rebuild() {
    const entityArr = [...allEntities.values()];
    // Only use entities that appear in edges (to keep graph clean)
    const edgeEntityIds = new Set();
    for (const e of allEdges) {
      edgeEntityIds.add(e.source_uuid);
      edgeEntityIds.add(e.target_uuid);
    }

    const relevantEntities = entityArr.filter(e => edgeEntityIds.has(e.uuid));

    // Cap at 60 nodes for performance
    const capped = relevantEntities
      .sort((a, b) => b.edgeCount - a.edgeCount)
      .slice(0, 60);

    const nodeMap = new Map();
    const w = canvas.width / dpr;
    const h = canvas.height / dpr;

    // Preserve positions of existing nodes
    const oldPositions = new Map();
    for (const n of nodes) oldPositions.set(n.id, { x: n.x, y: n.y });

    nodes = capped.map(ent => {
      const old = oldPositions.get(ent.uuid);
      return {
        id: ent.uuid,
        label: ent.name,
        edgeCount: ent.edgeCount,
        x: old ? old.x : w * 0.2 + Math.random() * w * 0.6,
        y: old ? old.y : h * 0.2 + Math.random() * h * 0.6,
        vx: 0, vy: 0,
      };
    });

    for (const n of nodes) nodeMap.set(n.id, n);

    links = allEdges
      .filter(e => nodeMap.has(e.source_uuid) && nodeMap.has(e.target_uuid))
      .map(e => ({
        source: nodeMap.get(e.source_uuid),
        target: nodeMap.get(e.target_uuid),
        label: e.name,
      }));

    document.getElementById('graphCount').textContent = `${nodes.length} nodes, ${links.length} edges`;
  }

  // Physics step
  function simulate() {
    const w = canvas.width / dpr;
    const h = canvas.height / dpr;
    const repulsion = 1800;
    const attraction = 0.008;
    const damping = 0.88;
    const centerPull = 0.002;

    // Repulsion between all pairs
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const a = nodes[i], b = nodes[j];
        let dx = a.x - b.x;
        let dy = a.y - b.y;
        let dist = Math.sqrt(dx * dx + dy * dy) || 1;
        let force = repulsion / (dist * dist);
        let fx = (dx / dist) * force;
        let fy = (dy / dist) * force;
        a.vx += fx; a.vy += fy;
        b.vx -= fx; b.vy -= fy;
      }
    }

    // Attraction along edges
    for (const link of links) {
      const a = link.source, b = link.target;
      let dx = b.x - a.x;
      let dy = b.y - a.y;
      let dist = Math.sqrt(dx * dx + dy * dy) || 1;
      let force = (dist - 80) * attraction;
      let fx = (dx / dist) * force;
      let fy = (dy / dist) * force;
      a.vx += fx; a.vy += fy;
      b.vx -= fx; b.vy -= fy;
    }

    // Pull toward center
    const cx = w / 2, cy = h / 2;
    for (const n of nodes) {
      n.vx += (cx - n.x) * centerPull;
      n.vy += (cy - n.y) * centerPull;
    }

    // Apply velocity
    for (const n of nodes) {
      if (n === dragNode) { n.vx = 0; n.vy = 0; continue; }
      n.vx *= damping;
      n.vy *= damping;
      n.x += n.vx;
      n.y += n.vy;
      // Bounds
      n.x = Math.max(20, Math.min(w - 20, n.x));
      n.y = Math.max(20, Math.min(h - 20, n.y));
    }
  }

  // Draw
  function draw() {
    const w = canvas.width / dpr;
    const h = canvas.height / dpr;
    ctx.clearRect(0, 0, w, h);

    if (nodes.length === 0) {
      ctx.fillStyle = '#8a7d6a';
      ctx.font = '13px Inter, system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Waiting for graph data...', w / 2, h / 2);
      return;
    }

    // Edges
    for (const link of links) {
      const isHovered = hoveredNode && (link.source === hoveredNode || link.target === hoveredNode);
      ctx.beginPath();
      ctx.moveTo(link.source.x, link.source.y);
      ctx.lineTo(link.target.x, link.target.y);
      ctx.strokeStyle = isHovered ? 'rgba(245,166,35,0.5)' : 'rgba(212,149,43,0.12)';
      ctx.lineWidth = isHovered ? 1.5 : 0.7;
      ctx.stroke();
    }

    // Nodes
    const maxEdge = Math.max(1, ...nodes.map(n => n.edgeCount));
    for (const n of nodes) {
      const ratio = n.edgeCount / maxEdge;
      const r = 4 + ratio * 10;
      const isHovered = n === hoveredNode;

      // Glow
      if (ratio > 0.3 || isHovered) {
        const glow = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, r * 3);
        glow.addColorStop(0, isHovered ? 'rgba(255,189,69,0.35)' : 'rgba(245,166,35,0.15)');
        glow.addColorStop(1, 'rgba(245,166,35,0)');
        ctx.beginPath();
        ctx.arc(n.x, n.y, r * 3, 0, Math.PI * 2);
        ctx.fillStyle = glow;
        ctx.fill();
      }

      // Node circle
      ctx.beginPath();
      ctx.arc(n.x, n.y, r, 0, Math.PI * 2);

      const gradient = ctx.createRadialGradient(n.x - r * 0.3, n.y - r * 0.3, 0, n.x, n.y, r);
      if (isHovered) {
        gradient.addColorStop(0, '#ffce54');
        gradient.addColorStop(1, '#f5a623');
      } else {
        gradient.addColorStop(0, lerpColor('#d4952b', '#f5a623', ratio));
        gradient.addColorStop(1, lerpColor('#7a5c2e', '#e8742a', ratio));
      }
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.strokeStyle = isHovered ? 'rgba(255,189,69,0.8)' : 'rgba(255,255,255,0.15)';
      ctx.lineWidth = isHovered ? 2 : 0.5;
      ctx.stroke();

      // Label
      if (ratio > 0.2 || isHovered || nodes.length < 25) {
        ctx.fillStyle = isHovered ? '#fff' : `rgba(240,230,211,${0.4 + ratio * 0.6})`;
        ctx.font = `${isHovered ? 'bold ' : ''}${Math.round(10 + ratio * 3)}px Inter, system-ui, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(n.label, n.x, n.y - r - 4);
      }
    }
  }

  function lerpColor(a, b, t) {
    const ah = parseInt(a.slice(1), 16);
    const bh = parseInt(b.slice(1), 16);
    const ar = (ah >> 16) & 0xff, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
    const br = (bh >> 16) & 0xff, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
    const rr = Math.round(ar + (br - ar) * t);
    const rg = Math.round(ag + (bg - ag) * t);
    const rb = Math.round(ab + (bb - ab) * t);
    return `rgb(${rr},${rg},${rb})`;
  }

  // Animation loop
  function tick() {
    simulate();
    draw();
    requestAnimationFrame(tick);
  }

  // Mouse interaction
  function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  function findNode(x, y) {
    const maxEdge = Math.max(1, ...nodes.map(n => n.edgeCount));
    for (let i = nodes.length - 1; i >= 0; i--) {
      const n = nodes[i];
      const r = 4 + (n.edgeCount / maxEdge) * 10 + 4;
      const dx = n.x - x, dy = n.y - y;
      if (dx * dx + dy * dy < r * r) return n;
    }
    return null;
  }

  canvas.addEventListener('mousedown', (e) => {
    const pos = getMousePos(e);
    dragNode = findNode(pos.x, pos.y);
  });

  canvas.addEventListener('mousemove', (e) => {
    const pos = getMousePos(e);
    mouseX = pos.x; mouseY = pos.y;
    hoveredNode = findNode(pos.x, pos.y);
    canvas.style.cursor = hoveredNode ? 'grab' : 'default';
    if (dragNode) {
      dragNode.x = pos.x;
      dragNode.y = pos.y;
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mouseup', () => { dragNode = null; });
  canvas.addEventListener('mouseleave', () => { dragNode = null; hoveredNode = null; });

  // Touch support
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const pos = { x: touch.clientX - rect.left, y: touch.clientY - rect.top };
    dragNode = findNode(pos.x, pos.y);
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (!dragNode) return;
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    dragNode.x = touch.clientX - rect.left;
    dragNode.y = touch.clientY - rect.top;
  }, { passive: false });

  canvas.addEventListener('touchend', () => { dragNode = null; });

  // Expose rebuild for external calls
  graphSim = { rebuild };

  rebuild();
  tick();
}

// ═══════════════════════════════════════════════════
// RENDER: Topics
// ═══════════════════════════════════════════════════
function renderTopicColumn(columnId, data) {
  const col = document.getElementById(columnId);
  const heading = col.querySelector('.topic-heading');

  // Remove loading placeholder
  const placeholder = col.querySelector('.loading-placeholder');
  if (placeholder) placeholder.remove();

  if (!data || !data.success) {
    col.insertAdjacentHTML('beforeend', '<div class="topic-item" style="color:var(--cream-faint)">No data</div>');
    return;
  }

  let html = '';

  // Show entities first, then edges as context
  if (data.entities && data.entities.length > 0) {
    // Deduplicate by name
    const seen = new Set();
    for (const ent of data.entities) {
      if (seen.has(ent.name)) continue;
      seen.add(ent.name);

      // Find a relevant fact from edges
      const relatedEdge = (data.edges || []).find(
        e => e.source_uuid === ent.uuid || e.target_uuid === ent.uuid
      );

      html += `<div class="topic-item fade-in">
        <span class="topic-item-name">${escHtml(ent.name)}</span>
        ${relatedEdge ? `<span class="topic-item-detail">${escHtml(relatedEdge.fact || relatedEdge.name)}</span>` : ''}
      </div>`;
    }
  }

  // If no entities, show episodes
  if (!html && data.episodes && data.episodes.length > 0) {
    for (const ep of data.episodes.slice(0, 8)) {
      html += `<div class="topic-item fade-in">
        <span class="topic-item-name">${escHtml(ep.name || 'Memory')}</span>
        <span class="topic-item-detail">${escHtml(truncate(ep.content || '', 100))}</span>
      </div>`;
    }
  }

  if (!html) {
    html = '<div class="topic-item" style="color:var(--cream-faint)">Exploring...</div>';
  }

  col.insertAdjacentHTML('beforeend', html);
}

// ═══════════════════════════════════════════════════
// HELPERS
// ═══════════════════════════════════════════════════
function escHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function truncate(str, len) {
  if (str.length <= len) return str;
  return str.slice(0, len).replace(/\s+\S*$/, '') + '...';
}

// ═══════════════════════════════════════════════════
// MAIN LOAD LOGIC
// ═══════════════════════════════════════════════════
async function loadDashboard() {
  const badge = document.getElementById('statusBadge');
  badge.className = 'status-badge loading';
  badge.textContent = 'Loading';

  try {
    // Phase 1: Main broad query to get the overview
    const mainQueries = [
      delve('everything happening at EthBoulder'),
      delve('all people participants speakers'),
      delve('projects tools platforms being built'),
    ];

    // Phase 2: Topic queries
    const topicQueries = [
      { query: 'people and who they are', col: 'topicPeople' },
      { query: 'projects being built', col: 'topicProjects' },
      { query: 'ideas and themes', col: 'topicIdeas' },
      { query: 'places and spaces', col: 'topicPlaces' },
      { query: 'emerging connections and patterns', col: 'topicEmerging' },
    ];

    // Fire all queries in parallel
    const allPromises = [
      ...mainQueries,
      ...topicQueries.map(t => delve(t.query)),
    ];

    const results = await Promise.allSettled(allPromises);

    // Process main queries (first 3)
    for (let i = 0; i < 3; i++) {
      if (results[i].status === 'fulfilled') {
        mergeResults(results[i].value);
      }
    }

    // Process topic queries (next 5) — also merge into global state
    let topicsLoaded = 0;
    for (let i = 0; i < topicQueries.length; i++) {
      const result = results[3 + i];
      if (result.status === 'fulfilled') {
        mergeResults(result.value);
        renderTopicColumn(topicQueries[i].col, result.value);
        topicsLoaded++;
      } else {
        renderTopicColumn(topicQueries[i].col, null);
      }
    }

    document.getElementById('topicsStatus').textContent = `${topicsLoaded}/5 queries complete`;

    // Render all sections
    renderStats();
    renderEpisodes();
    renderEntities();

    if (graphSim) {
      graphSim.rebuild();
    }

    badge.className = 'status-badge live';
    badge.textContent = 'Live';

  } catch (err) {
    console.error('Dashboard load error:', err);
    const badge = document.getElementById('statusBadge');
    badge.className = 'status-badge error';
    badge.textContent = 'Error';
  }
}

// ═══════════════════════════════════════════════════
// COUNTDOWN & AUTO-REFRESH
// ═══════════════════════════════════════════════════
function startCountdown() {
  countdown = CONFIG.REFRESH_SEC;
  if (refreshTimer) clearInterval(refreshTimer);

  refreshTimer = setInterval(() => {
    countdown--;
    document.getElementById('countdown').textContent = countdown + 's';
    if (countdown <= 0) {
      clearInterval(refreshTimer);
      loadDashboard().then(() => startCountdown());
    }
  }, 1000);
}

// ═══════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════
document.addEventListener('DOMContentLoaded', () => {
  initForceGraph();
  loadDashboard().then(() => startCountdown());
});
</script>

</body>
</html>
